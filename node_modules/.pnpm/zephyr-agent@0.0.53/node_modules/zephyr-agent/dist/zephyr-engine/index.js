"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZephyrEngine = void 0;
exports.is_zephyr_dependency_pair = is_zephyr_dependency_pair;
exports.is_zephyr_resolved_dependency = is_zephyr_resolved_dependency;
exports.readPackageJson = readPackageJson;
const tslib_1 = require("tslib");
const is_ci_1 = tslib_1.__importDefault(require("is-ci"));
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const zephyr_edge_contract_1 = require("zephyr-edge-contract");
const login_1 = require("../lib/auth/login");
const ze_util_get_git_info_1 = require("../lib/build-context/ze-util-get-git-info");
const ze_util_read_package_json_1 = require("../lib/build-context/ze-util-read-package-json");
const get_upload_strategy_1 = require("../lib/deployment/get-upload-strategy");
const distributed_hash_control_1 = require("../lib/edge-hash-list/distributed-hash-control");
const get_missing_assets_1 = require("../lib/edge-hash-list/get-missing-assets");
const get_application_configuration_1 = require("../lib/edge-requests/get-application-configuration");
const get_build_id_1 = require("../lib/edge-requests/get-build-id");
const errors_1 = require("../lib/errors");
const logging_1 = require("../lib/logging");
const picocolor_1 = require("../lib/logging/picocolor");
const ze_log_event_1 = require("../lib/logging/ze-log-event");
const app_deploy_result_cache_1 = require("../lib/node-persist/app-deploy-result-cache");
const ze_build_snapshot_1 = require("../lib/transformers/ze-build-snapshot");
const resolve_remote_dependency_1 = require("./resolve_remote_dependency");
function is_zephyr_dependency_pair(dep) {
    return !!dep;
}
function is_zephyr_resolved_dependency(dep) {
    return dep !== null;
}
/**
 * IMPORTANT: do NOT add methods to this class, keep it lean! IMPORTANT: use `await
 * ZephyrEngine.create(context)` to create an instance ZephyrEngine instance represents
 * current state of a build if there are methods - they should call pure functions from
 * ./internal
 */
class ZephyrEngine {
    /** This is intentionally PRIVATE use `await ZephyrEngine.create(context)` */
    constructor(options) {
        // build context properties
        this.env = { isCI: is_ci_1.default, target: 'web' };
        this.buildProperties = { output: './dist' };
        // resolved dependencies
        this.federated_dependencies = null;
        // build hook properties
        this.build_start_time = null;
        this.build_id = null;
        this.snapshotId = null;
        this.hash_list = null;
        this.resolved_hash_list = null;
        this.version_url = null;
        this.builder = options.builder;
    }
    static defer_create() {
        let resolve;
        let reject;
        return {
            zephyr_engine_defer: new Promise((res, rej) => {
                resolve = res;
                reject = rej;
            }),
            // All zephyr_engine_defer calls are wrapped inside a try/catch,
            // so its safe to reject the promise here and expect it to be handled
            zephyr_defer_create(options) {
                ZephyrEngine.create(options).then(resolve, reject);
            },
        };
    }
    // todo: extract to a separate fn
    static async create(options) {
        const context = options.context || process.cwd();
        logging_1.ze_log.init(`Initializing: Zephyr Engine for ${context}...`);
        const ze = new ZephyrEngine({ context, builder: options.builder });
        logging_1.ze_log.init('Initializing: npm package info...');
        ze.npmProperties = await (0, ze_util_read_package_json_1.getPackageJson)(context);
        logging_1.ze_log.init('Initializing: git info...');
        ze.gitProperties = await (0, ze_util_get_git_info_1.getGitInfo)();
        // mut: set application_uid and applicationProperties
        mut_zephyr_app_uid(ze);
        const application_uid = ze.application_uid;
        // starting async load of application configuration, build_id and hash_list
        logging_1.ze_log.init('Initializing: checking authentication...');
        await (0, login_1.checkAuth)();
        logging_1.ze_log.init('Initialized: loading application configuration...');
        ze.application_configuration = (0, get_application_configuration_1.getApplicationConfiguration)({ application_uid });
        ze.application_configuration
            .then((appConfig) => {
            const { username, email, EDGE_URL } = appConfig;
            logging_1.ze_log.init('Loaded: application configuration', { username, email, EDGE_URL });
        })
            .catch((err) => logging_1.ze_log.init(`Failed to get application configuration: ${err}`));
        await ze.start_new_build();
        void ze.logger.then(async (logger) => {
            const { username } = await ze.application_configuration;
            const buildId = await ze.build_id;
            logger({
                level: 'info',
                action: 'build:info:user',
                ignore: true,
                message: `Hi ${(0, picocolor_1.cyanBright)(username)}!\n${(0, picocolor_1.white)(application_uid)}${(0, picocolor_1.yellow)(`#${buildId}`)}\n`,
            });
        });
        return ze;
    }
    /**
     * Accept two argument to resolve remote dependencies:
     *
     * @param dependencyPair, Includes name and versions (the url includes localhost),
     * @param platform, Atm this is React Native specific to resolve correct platform `ios`
     *   or `android`
     */
    async resolve_remote_dependencies(deps) {
        if (!deps) {
            return null;
        }
        const app_config = await this.application_configuration;
        const ze_dependencies = this.npmProperties.zephyrDependencies;
        const platform = this.env.target;
        const build_context_json = {
            target: this.env.target,
            isCI: is_ci_1.default,
            branch: this.gitProperties.git.branch,
            username: app_config.username,
        };
        // convert to base64
        const build_context = Buffer.from(JSON.stringify(build_context_json)).toString('base64');
        logging_1.ze_log.remotes('resolve_remote_dependencies.deps', deps, 'platform', platform, 'ze_dependencies', ze_dependencies);
        const resolution_errors = [];
        const tasks = deps.map(async (dep) => {
            var _a, _b, _c, _d, _e;
            const [app_name, project_name, org_name] = dep.name.split('.', 3);
            const ze_dependency = ze_dependencies === null || ze_dependencies === void 0 ? void 0 : ze_dependencies[dep.name];
            const [ze_app_name, ze_project_name, ze_org_name] = (_b = (_a = ze_dependency === null || ze_dependency === void 0 ? void 0 : ze_dependency.app_uid) === null || _a === void 0 ? void 0 : _a.split('.')) !== null && _b !== void 0 ? _b : [];
            // Key might be only the app name
            const dep_application_uid = (0, zephyr_edge_contract_1.createApplicationUid)({
                org: (_c = ze_org_name !== null && ze_org_name !== void 0 ? ze_org_name : org_name) !== null && _c !== void 0 ? _c : this.gitProperties.app.org,
                project: (_d = ze_project_name !== null && ze_project_name !== void 0 ? ze_project_name : project_name) !== null && _d !== void 0 ? _d : this.gitProperties.app.project,
                name: ze_app_name !== null && ze_app_name !== void 0 ? ze_app_name : app_name,
            });
            // if default url is url - set as default, if not use app remote_host as default
            // if default url is not url - send it as a semver to deps resolution
            const tuple = await zephyr_edge_contract_1.ZeUtils.PromiseTuple((0, resolve_remote_dependency_1.resolve_remote_dependency)({
                application_uid: dep_application_uid,
                version: (_e = ze_dependency === null || ze_dependency === void 0 ? void 0 : ze_dependency.version) !== null && _e !== void 0 ? _e : dep.version,
                platform,
                build_context,
            }));
            // If you couldn't resolve remote dependency, skip replacing it
            if (!zephyr_edge_contract_1.ZeUtils.isSuccessTuple(tuple)) {
                logging_1.ze_log.remotes(`Failed to resolve remote dependency: ${dep.name}@${dep.version}`, 'skipping...');
                resolution_errors.push({ dep, error: tuple[0] });
                return null;
            }
            logging_1.ze_log.remotes(`Resolved dependency: ${tuple[1].default_url}`);
            if (dep.name === tuple[1].name) {
                return tuple[1];
            }
            return Object.assign({}, tuple[1], { name: dep.name, version: dep.version });
        });
        const resolution_results = await Promise.all(tasks);
        // If there are resolution errors, log it with summary
        if (resolution_errors.length > 0) {
            const logger = await this.logger;
            const errorSummary = resolution_errors
                .map(({ dep, error }) => {
                const errorMessage = errors_1.ZephyrError.is(error)
                    ? `Error code: ${error.code}`
                    : `Unknown error`;
                const version = errors_1.ZephyrError.is(error) && error.template && 'version' in error.template
                    ? error.template.version
                    : dep.version;
                return `  - ${dep.name}@${version} -> ${errorMessage}`;
            })
                .join('\n');
            logger({
                level: 'warn',
                action: 'build:error:dependency_resolution',
                message: `Failed to resolve remote dependencies:
${errorSummary}\n
More information on remote dependency resolution please check:
https://docs.zephyr-cloud.io/how-to/dependency-management`,
            });
        }
        this.federated_dependencies = resolution_results.filter(is_zephyr_resolved_dependency);
        return this.federated_dependencies;
    }
    async start_new_build() {
        logging_1.ze_log.init('Starting new build');
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const ze = this;
        ze.build_start_time = Date.now();
        if ((await ze.build_id) && (await ze.snapshotId)) {
            logging_1.ze_log.init('Skip: creating new build because no assets was uploaded');
            return;
        }
        const application_uid = ze.application_uid;
        logging_1.ze_log.init('Initializing: loading of hash list');
        ze.hash_list = (0, distributed_hash_control_1.get_hash_list)(application_uid);
        ze.hash_list
            .then((hash_set) => {
            ze.resolved_hash_list = hash_set;
            logging_1.ze_log.app(`Loaded: hash list with ${hash_set.hash_set.size} entries`);
        })
            .catch((err) => logging_1.ze_log.app(`Failed to get hash list: ${err}`));
        logging_1.ze_log.init('Initializing: loading of build id');
        ze.build_id = (0, get_build_id_1.getBuildId)(application_uid);
        ze.build_id
            .then((buildId) => logging_1.ze_log.app(`Loaded build id "${buildId}"`))
            .catch((err) => logging_1.ze_log.app(`Failed to get build id: ${err}`));
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        if (!ze.logger) {
            logging_1.ze_log.init('Initializing: logger');
            let resolve;
            ze.logger = new Promise((r) => (resolve = r));
            // internally logger will try to load app_config
            void Promise.all([ze.application_configuration, ze.build_id]).then((record) => {
                const buildId = record[1];
                logging_1.ze_log.init('Initialized: application configuration, build id and hash list');
                resolve((0, ze_log_event_1.logger)({ application_uid, buildId, git: ze.gitProperties.git }));
            });
        }
        // snapshotId is a flat version of application_uid and build_id
        ze.snapshotId = Promise.all([ze.application_configuration, ze.build_id]).then(async (record) => (0, zephyr_edge_contract_1.flatCreateSnapshotId)(Object.assign(Object.assign({}, ze.applicationProperties), { buildId: record[1], username: record[0].username })));
    }
    async build_finished() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const zephyr_engine = this;
        const logger = await zephyr_engine.logger;
        const zeStart = zephyr_engine.build_start_time;
        const versionUrl = zephyr_engine.version_url;
        const dependencies = zephyr_engine.federated_dependencies;
        const if_target_is_react_native = zephyr_engine.env.target === 'ios' || zephyr_engine.env.target === 'android';
        if (zeStart && versionUrl) {
            if (dependencies && dependencies.length > 0) {
                logger({
                    level: 'info',
                    action: 'build:info:user',
                    ignore: true,
                    message: if_target_is_react_native
                        ? `Resolved zephyr dependencies: ${dependencies
                            .map((dep) => dep.name)
                            .join(', ')} for platform: ${zephyr_engine.env.target}`
                        : `Resolved zephyr dependencies: ${dependencies
                            .map((dep) => dep.name)
                            .join(', ')}`,
                });
            }
            logger({
                level: 'trace',
                action: 'deploy:url',
                message: `Deployed to ${(0, picocolor_1.cyanBright)('Zephyr')}'s edge in ${(0, picocolor_1.yellow)(`${Date.now() - zeStart}`)}ms.\n\n${(0, picocolor_1.cyanBright)(versionUrl)}`,
            });
        }
        this.build_id = null;
        this.snapshotId = null;
        this.version_url = null;
        this.build_start_time = null;
    }
    async upload_assets(props) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const zephyr_engine = this;
        logging_1.ze_log.upload('Initializing: upload assets');
        const { assetsMap, buildStats, mfConfig } = props;
        if (!zephyr_engine.application_uid || !zephyr_engine.build_id) {
            logging_1.ze_log.upload('Failed to upload assets: missing application_uid or build_id');
            return;
        }
        await zephyr_engine.build_id;
        const hash_set = zephyr_engine.resolved_hash_list;
        const missingAssets = (0, get_missing_assets_1.get_missing_assets)({
            assetsMap,
            hash_set: hash_set !== null && hash_set !== void 0 ? hash_set : { hash_set: new Set() },
        });
        // upload data
        const snapshot = await (0, ze_build_snapshot_1.createSnapshot)(zephyr_engine, {
            assets: assetsMap,
            mfConfig,
        });
        const upload_options = {
            snapshot,
            getDashData: () => buildStats,
            assets: {
                assetsMap,
                missingAssets,
            },
        };
        // upload
        const platform = (await zephyr_engine.application_configuration).PLATFORM;
        const strategy = (0, get_upload_strategy_1.getUploadStrategy)(platform);
        zephyr_engine.version_url = await strategy(zephyr_engine, upload_options);
        if (is_ci_1.default) {
            const application_uid = zephyr_engine.application_uid;
            await (0, app_deploy_result_cache_1.setAppDeployResult)(application_uid, { urls: [zephyr_engine.version_url] });
        }
        await this.build_finished();
    }
}
exports.ZephyrEngine = ZephyrEngine;
function mut_zephyr_app_uid(ze) {
    ze.applicationProperties = {
        org: ze.gitProperties.app.org,
        project: ze.gitProperties.app.project,
        name: ze.npmProperties.name,
        version: ze.npmProperties.version,
    };
    ze.application_uid = (0, zephyr_edge_contract_1.createApplicationUid)(ze.applicationProperties);
}
function readPackageJson(root) {
    const packageJsonPath = (0, node_path_1.join)(root, 'package.json');
    const packageJsonContent = (0, node_fs_1.existsSync)(packageJsonPath)
        ? (0, node_fs_1.readFileSync)(packageJsonPath, 'utf-8')
        : '{}';
    return JSON.parse(packageJsonContent);
}
//# sourceMappingURL=index.js.map