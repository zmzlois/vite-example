"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAuth = checkAuth;
exports.isTokenStillValid = isTokenStillValid;
const tslib_1 = require("tslib");
const jose = tslib_1.__importStar(require("jose"));
const readline = tslib_1.__importStar(require("node:readline"));
const zephyr_edge_contract_1 = require("zephyr-edge-contract");
const errors_1 = require("../errors");
const http_request_1 = require("../http/http-request");
const logging_1 = require("../logging");
const picocolor_1 = require("../logging/picocolor");
const ze_log_event_1 = require("../logging/ze-log-event");
const secret_token_1 = require("../node-persist/secret-token");
const session_lock_1 = require("../node-persist/session-lock");
const storage_keys_1 = require("../node-persist/storage-keys");
const token_1 = require("../node-persist/token");
const auth_flags_1 = require("./auth-flags");
const websocket_1 = require("./websocket");
/**
 * Check if the user is already authenticated. If not, ask if they want to open a browser
 * to authenticate. Display a message to the console.
 *
 * @returns The token as a string.
 */
async function checkAuth() {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
        const secret_token = (0, secret_token_1.getSecretToken)();
        if (secret_token) {
            (0, ze_log_event_1.logFn)('debug', 'Token found in environment. Using secret token for authentication.');
            return;
        }
        const existingToken = await (0, token_1.getToken)();
        if (existingToken) {
            // Check if the token has a valid expiration date.
            if (isTokenStillValid(existingToken, auth_flags_1.TOKEN_EXPIRY.SHORT_VALIDITY_CHECK_SEC)) {
                logging_1.ze_log.auth('You are already logged in');
                return;
            }
            await (0, token_1.removeToken)();
        }
        // In non-TTY environments it's expected that a ZE_SECRET_TOKEN is present
        // since user cannot interact with it.
        if (!picocolor_1.isTTY) {
            (0, ze_log_event_1.logFn)('warn', `Could not load ${storage_keys_1.StorageKeys.ze_secret_token}.`);
        }
        // No valid token found; initiate authentication.
        (0, ze_log_event_1.logFn)('', `${(0, picocolor_1.yellow)('Authentication required')} - You need to log in to Zephyr Cloud`);
        // Get authentication URL first
        const sessionKey = tslib_1.__addDisposableResource(env_1, (0, session_lock_1.getSessionKey)(), false);
        const authUrl = await getAuthenticationURL(sessionKey.session);
        if (!sessionKey.owner) {
            (0, ze_log_event_1.logFn)('', (0, picocolor_1.gray)('Waiting for session unlock...'));
        }
        const browserController = new AbortController();
        // Tries to open the browser to authenticate the user
        void promptForAuthAction(authUrl, browserController.signal)
            .then(() => openUrl(authUrl))
            .catch(() => fallbackManualLogin(authUrl));
        // We are the owner of the session request, join websocket room
        // and wait for the access token
        if (sessionKey.owner) {
            const newToken = await waitForAccessToken(sessionKey.session).finally(() => browserController.abort());
            await (0, token_1.saveToken)(newToken);
        }
        else {
            // node-persist is not concurrent safe, so we need to wait for the unlock
            // before next readToken() calls can happen
            // https://github.com/simonlast/node-persist/issues/108#issuecomment-1442305246
            await (0, session_lock_1.waitForUnlock)(browserController.signal);
            const token = await (0, token_1.getToken)();
            // Unlock also happens on timeout, so we need to check if the token was
            // actually saved or not
            if (!token) {
                throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
                    message: 'No token found after authentication finished, did it timeout?',
                });
            }
        }
        (0, ze_log_event_1.logFn)('', `${(0, picocolor_1.green)('✓')} You are now logged in to Zephyr Cloud\n`);
    }
    catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
    }
    finally {
        tslib_1.__disposeResources(env_1);
    }
}
/**
 * Decides whether the token is still valid based on its expiration time.
 *
 * @param token The token to check.
 * @param gap In seconds
 * @returns Boolean indicating if the token is still valid.
 */
function isTokenStillValid(token, gap = 0) {
    // Attempts to decode the token
    try {
        const decodedToken = jose.decodeJwt(token);
        if (decodedToken.exp) {
            return new Date(decodedToken.exp * 1000) > new Date(Date.now() + gap * 1000);
        }
        // No expiration date found, invalid token.
        return false;
    }
    catch (_a) {
        // If the token is invalid, return false.
        return false;
    }
}
/** Prompts the user to choose an authentication action */
async function promptForAuthAction(authUrl, signal) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        signal,
    });
    return new Promise((resolve) => {
        rl.question((0, ze_log_event_1.formatLogMsg)(`
${authUrl}

${(0, picocolor_1.gray)(`You can hit ${(0, picocolor_1.bold)((0, picocolor_1.white)('Enter'))} to open it up on your browser.`)}
`), { signal }, resolve);
    });
}
/** Helper to display manual login instructions with highlighted URL */
function fallbackManualLogin(url) {
    (0, ze_log_event_1.logFn)('', '');
    (0, ze_log_event_1.logFn)('', `An unexpected error happened when opening the browser.`);
    (0, ze_log_event_1.logFn)('', `${(0, picocolor_1.yellow)('Please open this URL in your browser to log in:')}`);
    (0, ze_log_event_1.logFn)('', url);
    (0, ze_log_event_1.logFn)('', `${(0, picocolor_1.blue)('⏳')} Waiting for you to complete authentication in browser...`);
}
/** Opens the given URL in the default browser. */
async function openUrl(url) {
    // Lazy loads `open` module
    // eslint-disable-next-line @typescript-eslint/consistent-type-imports
    const openModule = (await eval(`import('open')`));
    await openModule.default(url);
}
/** Generates the URL to authenticate the user. */
async function getAuthenticationURL(state) {
    const [ok, cause, data] = await (0, http_request_1.makeRequest)({
        path: zephyr_edge_contract_1.ze_api_gateway.auth_link,
        base: (0, zephyr_edge_contract_1.ZE_API_ENDPOINT)(),
        query: { state },
    });
    if (!ok) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
            cause,
            message: 'Could not get authentication URL',
        });
    }
    return data;
}
/** Waits for the access token to be received from the websocket. */
async function waitForAccessToken(sessionKey) {
    const { promise, resolve, reject } = (0, zephyr_edge_contract_1.PromiseWithResolvers)();
    const socket = (0, websocket_1.createSocket)((0, zephyr_edge_contract_1.ZEPHYR_API_ENDPOINT)());
    let timeoutHandle = null;
    // Helper to properly cleanup socket
    const cleanupSocket = () => {
        if (timeoutHandle) {
            clearTimeout(timeoutHandle);
            timeoutHandle = null;
        }
        socket.removeAllListeners();
        socket.disconnect();
        socket.close();
    };
    try {
        socket.once('access-token', (token) => {
            cleanupSocket();
            resolve(token);
        });
        // Creating errors outside of the listener closure makes the stack trace point
        // to waitForAccessToken fn instead of socket.io internals event emitter code.
        socket.once('access-token-error', (cause) => {
            cleanupSocket();
            reject(new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
                cause,
                message: 'Error getting access token',
            }));
        });
        socket.once('connect_error', (cause) => {
            cleanupSocket();
            reject(new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
                message: 'Could not connect to socket.',
                cause,
            }));
        });
        socket.emit('joinAccessTokenRoom', { state: sessionKey });
        // The user has a specified amount of time to log in through the browser.
        timeoutHandle = setTimeout(() => {
            cleanupSocket();
            reject(new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
                message: `Authentication timed out. Couldn't receive access token in ${auth_flags_1.DEFAULT_AUTH_COMPLETION_TIMEOUT_MS / 1000} seconds. Please try again.`,
            }));
        }, auth_flags_1.DEFAULT_AUTH_COMPLETION_TIMEOUT_MS);
        return await promise;
    }
    finally {
        cleanupSocket();
    }
}
//# sourceMappingURL=login.js.map