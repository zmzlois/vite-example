"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZephyrError = exports.discordUrl = exports.docsUrl = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("node:fs"));
const os = tslib_1.__importStar(require("node:os"));
const path = tslib_1.__importStar(require("node:path"));
const util = tslib_1.__importStar(require("node:util"));
const picocolor_1 = require("../logging/picocolor");
const codes_1 = require("./codes");
const zephyr_edge_contract_1 = require("zephyr-edge-contract");
exports.docsUrl = 'https://docs.zephyr-cloud.io/errors';
exports.discordUrl = 'https://zephyr-cloud.io/discord';
/**
 * ZephyrError is the base class for every error thrown by our builder plugins.
 *
 * Some messages have templates that mus be replaced with the `data` object. Use `{{
 * example }}` or `{{ example = value }}` to have a default value
 *
 * It's a subclass of Error, so it can be used in try/catch blocks.
 */
class ZephyrError extends Error {
    /**
     * Returns {@linkcode cause} if it's a `ZephyrError`, otherwise creates a new
     * `ZephyrError` for the provided type.
     */
    constructor(type, opts) {
        // Unwraps ERR_UNKNOWN if cause is known
        if (ZephyrError.is(opts === null || opts === void 0 ? void 0 : opts.cause)) {
            if ((0, codes_1.isZeErrorEqual)(type, codes_1.ZeErrors.ERR_UNKNOWN)) {
                return opts.cause;
            }
            // Use cause's data if none is provided
            if (!opts.data && opts.cause.data) {
                opts.data = opts.cause.data;
                opts.cause.data = undefined;
            }
        }
        let message = type.message;
        // replace all the templates
        if (opts) {
            message = (0, zephyr_edge_contract_1.formatString)(type.message, opts);
        }
        super(message.trim());
        this.code = ZephyrError.toZeCode(type);
        if (opts) {
            const { cause, data } = opts, template = tslib_1.__rest(opts, ["cause", "data"]);
            this.template = template;
            this.data = data;
            this.cause = cause;
        }
        // Simpler stack traces in VIte
        if (process.env['VITE']) {
            this._stack = this.stack;
        }
    }
    /** Checks if the given error is a ZephyrError and optionally matches the given code. */
    static is(err, codeOrType) {
        if (!(err instanceof ZephyrError)) {
            return false;
        }
        // No kind to filter
        if (!codeOrType) {
            return true;
        }
        return ZephyrError.toZeCode(codeOrType) === err.code;
    }
    /** Formats a Zephyr error code. */
    static toZeCode({ id, kind }) {
        const prefix = codes_1.ZeErrorCategories[kind];
        // we have less categories and more errors, so make sense to be ZEPPIII
        // where ZE is a constant, PP is the category, and I is the error id
        const paddedId = id.toString().padStart(3, '0');
        const paddedPrefix = prefix.toString().padStart(2, '0');
        return `ZE${paddedPrefix}${paddedId}`;
    }
    /**
     * Parses a Zephyr error code into a ZeErrorType.
     *
     * Returns {@linkcode ZeErrors.ERR_UNKNOWN} if the code could not be resolved.
     */
    static fromZeCode(code) {
        // ZEPPIII -> ZE PP III -> ZE (2) (3)
        const prefix = code.slice(2, 4);
        const id = code.slice(4);
        let category;
        for (const errorCategory of Object.keys(codes_1.ZeErrorCategories)) {
            if (codes_1.ZeErrorCategories[errorCategory] === prefix) {
                category = errorCategory;
                break;
            }
        }
        if (!category) {
            return codes_1.ZeErrors.ERR_UNKNOWN;
        }
        for (const error of Object.values(codes_1.ZeErrors)) {
            if (+error.id === +id && error.kind === category) {
                return error;
            }
        }
        return codes_1.ZeErrors.ERR_UNKNOWN;
    }
    static format(error) {
        const zeError = ZephyrError.is(error)
            ? error
            : new ZephyrError(codes_1.ZeErrors.ERR_UNKNOWN, {
                message: (error === null || error === void 0 ? void 0 : error.message) || String(error),
                cause: error,
            });
        const tmpFile = write_error_file(zeError);
        // Strings don't need to be inspected.
        const inspected = typeof zeError.data === 'object'
            ? util.inspect(zeError.data, false, 5, true)
            : zeError.data;
        const messages = [
            `${(0, picocolor_1.bold)((0, picocolor_1.underline)(zeError.code))}: ${zeError.message}`,
            `

Visit ${(0, picocolor_1.cyanBright)(`${exports.docsUrl}/${zeError.code}`)} for more information
Or join our ${(0, picocolor_1.blue)('Discord')} server at ${(0, picocolor_1.cyanBright)(exports.discordUrl)}

`.trim(),
            inspected !== '{}' && inspected,
            tmpFile &&
                (0, picocolor_1.blackBright)(`Complete error details available at ${(0, picocolor_1.whiteBright)(tmpFile)}`),
        ];
        return messages
            .filter((x) => !!x)
            .map((x) => x.trim())
            .join('\n\n');
    }
}
exports.ZephyrError = ZephyrError;
/** Attempts to write the error to a file in the temp directory. */
function write_error_file(zeError) {
    try {
        const tempPath = path.join(os.tmpdir(), `ze${Math.round(Math.random() * 10e9)}.json`);
        fs.writeFileSync(tempPath, JSON.stringify(format_error(zeError)), 'utf8');
        return tempPath;
    }
    catch (_a) {
        return undefined;
    }
}
function format_error(err) {
    if (!err) {
        return undefined;
    }
    const error = err;
    return Object.assign(Object.assign(Object.assign(Object.assign({}, error), { template: undefined }), error === null || error === void 0 ? void 0 : error.template), { data: error === null || error === void 0 ? void 0 : error.data, message: error === null || error === void 0 ? void 0 : error.message, stack: split_stack(error.stack, error.message), cause: format_error(error.cause) });
}
function split_stack(stack, message) {
    if (!stack) {
        return undefined;
    }
    // removes message from stack
    if (message) {
        stack = stack.slice(`Error: ${message}\n`.length);
    }
    return stack.split('\n').map((line) => (0, zephyr_edge_contract_1.stripAnsi)(line.trim()));
}
//# sourceMappingURL=zephyr-error.js.map