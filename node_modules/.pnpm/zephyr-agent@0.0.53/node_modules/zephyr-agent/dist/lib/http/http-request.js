"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseUrl = parseUrl;
exports.makeHttpRequest = makeHttpRequest;
exports.makeRequest = makeRequest;
exports.unwrapResponse = unwrapResponse;
const zephyr_edge_contract_1 = require("zephyr-edge-contract");
const errors_1 = require("../errors");
const debug_1 = require("../logging/debug");
const token_1 = require("../node-persist/token");
const fetch_with_retries_1 = require("./fetch-with-retries");
function applyApiHost(url) {
    // Add a query param hint in preview environments
    const is_preview = (0, zephyr_edge_contract_1.ZE_IS_PREVIEW)();
    const ze_api_endpoint_host = (0, zephyr_edge_contract_1.ZE_API_ENDPOINT_HOST)();
    const zephyr_api_endpoint = (0, zephyr_edge_contract_1.ZEPHYR_API_ENDPOINT)();
    if (is_preview && url.host === ze_api_endpoint_host) {
        url.searchParams.set('api_host', zephyr_api_endpoint);
    }
    return url;
}
/** Parses the URL string into a URL object */
function parseUrl(urlStr) {
    if (typeof urlStr === 'string') {
        return applyApiHost(new URL(urlStr));
    }
    else if (urlStr instanceof URL) {
        return applyApiHost(urlStr);
    }
    else {
        const url = new URL(urlStr.path, urlStr.base);
        for (const [key, value] of Object.entries(urlStr.query)) {
            url.searchParams.append(key, String(value));
        }
        return applyApiHost(url);
    }
}
/** Creates a redacted string of the response for logging */
function redactResponse(url, options, data, response, startTime = Date.now()) {
    var _a;
    const str = [
        `[${options.method || 'GET'}][${url}]: ${Date.now() - startTime}ms`,
        (data === null || data === void 0 ? void 0 : data.length) ? ` - ${(((_a = data.length) !== null && _a !== void 0 ? _a : 0) / 1024).toFixed(2)}kb` : '',
        response ? `Response: ${response}` : '',
        options ? `Options: ${JSON.stringify(options)}` : '',
    ].join('\n');
    return str
        .replace(/Bearer ([^"|']+)/gi, 'Bearer [REDACTED]')
        .replace(/"?jwt"?:["|\W']{0,2}([^"|']+)(["|'])/gi, 'jwt: [REDACTED]');
}
/** Main HTTP request function that handles the request and response */
async function makeHttpRequest(url, options = {}, data) {
    var _a, _b, _c, _d, _e;
    const startTime = Date.now();
    try {
        const response = await (0, fetch_with_retries_1.fetchWithRetries)(url, Object.assign(Object.assign({}, options), { body: data }));
        const resText = await response.text();
        if (response.status === 401) {
            // Clean the tokens and throw an error
            await (0, token_1.cleanTokens)();
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
                message: 'Unauthenticated request',
            });
        }
        if (response.status === 403) {
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_FORBIDDEN_ERROR, {
                message: 'Unauthorized request',
            });
        }
        const message = redactResponse(url, options, data, resText, startTime);
        if (message === 'Not Implemented') {
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_UNKNOWN, {
                message: 'Not implemented yet. Please get in contact with our support.',
            });
        }
        if (response.status === undefined) {
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_HTTP_ERROR, {
                content: 'No status code found',
                method: (_b = (_a = options.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== null && _b !== void 0 ? _b : 'GET',
                url: url.toString(),
                status: -1,
            });
        }
        if (!url.pathname.includes('application/logs')) {
            debug_1.ze_log.http(message);
        }
        // Only parses data if reply content is json
        const resData = (_c = (0, zephyr_edge_contract_1.safe_json_parse)(resText)) !== null && _c !== void 0 ? _c : resText;
        if (response.status >= 300) {
            throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_HTTP_ERROR, {
                status: response.status,
                url: url.toString(),
                content: typeof resData === 'string' ? resData : JSON.stringify(resData),
                method: (_e = (_d = options.method) === null || _d === void 0 ? void 0 : _d.toUpperCase()) !== null && _e !== void 0 ? _e : 'GET',
            });
        }
        return [true, null, resData];
    }
    catch (error) {
        return [false, error];
    }
}
/** Creates a request that returns a promise for the HTTP response */
function makeRequest(urlStr, options = {}, data) {
    const url = parseUrl(urlStr);
    return makeHttpRequest(url, options, data);
}
/** Transforms `Promise<HttpResponse<T>>` into `Promise<T>` */
async function unwrapResponse(response) {
    const [ok, error, data] = await response;
    if (!ok) {
        throw error;
    }
    return data;
}
//# sourceMappingURL=http-request.js.map