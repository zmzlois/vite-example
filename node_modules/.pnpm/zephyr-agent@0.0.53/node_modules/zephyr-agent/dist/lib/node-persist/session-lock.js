"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSessionKey = getSessionKey;
exports.waitForUnlock = waitForUnlock;
const tslib_1 = require("tslib");
const node_crypto_1 = require("node:crypto");
const fs = tslib_1.__importStar(require("node:fs"));
const promises_1 = require("node:timers/promises");
const proper_lockfile_1 = require("proper-lockfile");
const auth_flags_1 = require("../auth/auth-flags");
const logging_1 = require("../logging");
const storage_keys_1 = require("./storage-keys");
// 72 bits of entropy is more than enough (80b to have 50% collisions)
const SESSION_LENGTH = 9;
// 1/4 of a second, good balance between responsiveness and not hammering the filesystem
const UNLOCK_INTERVAL = 1000 / 4; // 250ms
/**
 * Returns a base64url session key to be used in a login process.
 *
 * This uses a sync-lock to ensure that multiple concurrent login processes uses the same
 * session key so once the first login is completed, the other concurrent logins also get
 * authorized without doing anything else than waiting in the same websocket room.
 */
function getSessionKey() {
    // crypto.randomBytes might tame some milliseconds, we generate it before locking
    // so we don't create time for concurrency issues to happen between locking and writing
    // the session key to file.
    let session = (0, node_crypto_1.randomBytes)(SESSION_LENGTH);
    const unlock = safeLockSync();
    // Another process has the lock = concurrent login is in progress,
    // use that session key instead
    if (!unlock) {
        logging_1.ze_log.misc('Lock is already held by another process, using the same session key');
        session = fs.readFileSync(storage_keys_1.ZE_SESSION_LOCK);
        // A second write here helps solve any concurrency between reading and writing
        // the session key to the lockfile. This is a rare case, but it can happen
        if (session.length !== SESSION_LENGTH) {
            session = fs.readFileSync(storage_keys_1.ZE_SESSION_LOCK);
        }
    }
    else {
        logging_1.ze_log.misc('Lock acquired, writing session key to lockfile');
        // read and write as array buffer
        fs.writeFileSync(storage_keys_1.ZE_SESSION_LOCK, session, { flush: true });
    }
    return {
        owner: !!unlock,
        session: session.toString('base64url'),
        // If we are the holder of the lock, unlock it and clean up the lockfile
        [Symbol.dispose]() {
            if (unlock) {
                unlock();
                // TODO: Remove this in the future, once >=0.0.48 is the minimum version
                //
                // Removes the lockfile to prevent older plugin versions (<0.0.48) from crashing
                // because `node-persist#forgiveParseErrors` wasn't set to true yet.
                setTimeout(fs.unlink, UNLOCK_INTERVAL, storage_keys_1.ZE_SESSION_LOCK, () => {
                    // no need to care about errors here, if the file is not there, it's fine
                    logging_1.ze_log.misc('Lock released and lockfile removed');
                });
            }
        },
    };
}
/** @returns Either a function to unlock the lock or null if the lock could not be acquired */
function safeLockSync(createIfNotExists = true) {
    try {
        // The timeout to the whole login process makes sense to keep the lock for the same amount of time
        return (0, proper_lockfile_1.lockSync)(storage_keys_1.ZE_SESSION_LOCK, { stale: auth_flags_1.DEFAULT_AUTH_COMPLETION_TIMEOUT_MS });
    }
    catch (error) {
        if (error.code === 'ELOCKED') {
            return null;
        }
        // Creates the file if it does not exist
        if (error.code === 'ENOENT' && createIfNotExists) {
            fs.writeFileSync(storage_keys_1.ZE_SESSION_LOCK, '', 'utf8');
            return safeLockSync(false);
        }
        throw error;
    }
}
/**
 * Checks if the lock is still held by the current process and resolves when the lock is
 * released.
 */
async function waitForUnlock(signal) {
    var _a, e_1, _b, _c;
    try {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (var _d = true, _e = tslib_1.__asyncValues((0, promises_1.setInterval)(UNLOCK_INTERVAL, null, { ref: false, signal })), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const _ = _c;
            // Stale works as a timeout for the loop
            if (!(0, proper_lockfile_1.checkSync)(storage_keys_1.ZE_SESSION_LOCK, { stale: auth_flags_1.DEFAULT_AUTH_COMPLETION_TIMEOUT_MS })) {
                return;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
//# sourceMappingURL=session-lock.js.map