"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApplicationConfiguration = getApplicationConfiguration;
exports.invalidateApplicationConfigCache = invalidateApplicationConfigCache;
const zephyr_edge_contract_1 = require("zephyr-edge-contract");
const login_1 = require("../auth/login");
const errors_1 = require("../errors");
const http_request_1 = require("../http/http-request");
const logging_1 = require("../logging");
const application_configuration_1 = require("../node-persist/application-configuration");
const token_1 = require("../node-persist/token");
async function loadApplicationConfiguration({ application_uid, }) {
    if (!application_uid) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_MISSING_APPLICATION_UID);
    }
    const token = await (0, token_1.getToken)();
    const application_config_url = new URL(`${zephyr_edge_contract_1.ze_api_gateway.application_config}/${application_uid}`, (0, zephyr_edge_contract_1.ZE_API_ENDPOINT)());
    const [ok, cause, data] = await (0, http_request_1.makeRequest)(application_config_url, {
        headers: { Authorization: `Bearer ${token}` },
    });
    if (!ok || !(data === null || data === void 0 ? void 0 : data.value)) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_LOAD_APP_CONFIG, {
            application_uid,
            cause,
            data: {
                url: application_config_url.toString(),
            },
        });
    }
    return Object.assign(Object.assign({}, data.value), { fetched_at: Date.now() });
}
// --- 1. Module-level cache --------------------------------------------------
/** The single shared promise (null when no request is in flight). */
let inFlight = null;
/** The last successful result (null until we have fetched at least once). */
let cachedConfig = null;
/**
 * Gather all calls until the first returns result:
 *
 * - No parallel requests to api
 * - Almost all actual data
 *
 * Note: not the best solution, but works until we use the same application_uid during
 * execution
 */
async function getApplicationConfiguration({ application_uid, }) {
    // Fast path: we already have a valid cached config
    if (cachedConfig && cachedConfig.application_uid === application_uid) {
        if ((0, login_1.isTokenStillValid)(cachedConfig.jwt) &&
            cachedConfig.fetched_at &&
            Date.now() - cachedConfig.fetched_at <= 60 * 1000) {
            logging_1.ze_log.app('Using cached application configuration');
            return cachedConfig;
        }
        // If the cached config is invalid, clear it
        cachedConfig = null;
    }
    // Another request already in flight → piggy-back on it
    if (inFlight)
        return inFlight;
    // We're the first caller → actually start the fetch
    logging_1.ze_log.app('Getting application configuration from node-persist');
    inFlight = (async () => {
        const storedAppConfig = await (0, application_configuration_1.getAppConfig)(application_uid);
        if (!storedAppConfig ||
            (storedAppConfig &&
                (!(0, login_1.isTokenStillValid)(storedAppConfig.jwt) ||
                    !(storedAppConfig === null || storedAppConfig === void 0 ? void 0 : storedAppConfig.fetched_at) ||
                    Date.now() - storedAppConfig.fetched_at > 60 * 1000))) {
            logging_1.ze_log.app('Loading Application Configuration from API...');
            const loadedAppConfig = await loadApplicationConfiguration({ application_uid });
            logging_1.ze_log.app('Saving Application Configuration to node-persist...');
            await (0, application_configuration_1.saveAppConfig)(application_uid, loadedAppConfig);
            return loadedAppConfig;
        }
        else {
            return storedAppConfig;
        }
    })()
        .then((config) => {
        cachedConfig = config; // cache the good result
        return config;
    })
        .finally(() => {
        inFlight = null; // allow future refreshes
    });
    return inFlight;
}
/** Invalidate the cached application configuration */
function invalidateApplicationConfigCache() {
    cachedConfig = null;
}
//# sourceMappingURL=get-application-configuration.js.map